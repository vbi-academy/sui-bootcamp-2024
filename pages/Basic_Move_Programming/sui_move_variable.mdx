# Move on basics

Trước khi nói về các kiểu dữ liệu, hãy xem cách để khai báo và đặt tên biến trong Sui Move 

Trong Sui move, ta dùng `let` để khai báo và khởi tạo các biến (varibales). Sau khi khai báo biến, bạn có thể dễ dàng access và chỉnh sửa lại. Có nhiều kiểu để khai báo và khởi tạo biến: 

```rust
let <Variable> : <Type> 
let <Variable> = <Expression> 
let <variable> : <Type> = <Expression> 
``` 

Đây là ví dụ: 


```rust
let hello;
let hello_world : u8;
let hello_sui_bootcamp = True;
let hello_everyone : u8 = 20;

```

Tuy nhiên ngoài từ khoá `let` cho các giá trị immutable thì ta còn có `let mut` cho việc thay đổi dữ liệu 

Ngoài ra, ta còn có từ hằng số (`const`) được dùng để tạo ra các giá trị không thể thay thế. Gọi là hằng số. Đây là ví dụ khi khởi tạo hằng số: 

```
const <Variable> : <Type> = <Expression>
```

Hằng số (Constants) có thể được định nghĩa bằng bất kỳ kiểu dữ liệu nào. Dưới đây là một số điểm quan trọng cần biết về hằng số:
* Không thể thay đổi giá trị sau khi đã được định nghĩa
* Hằng số không thể truy cập từ bên ngoài module của nó.

```rust 

module sui_bootcamp::constants {
		
	const MAX : u64 = 100;

	public fun is_max(num: u64): bool {
		num == MAX
	}

}
```


# Các kiểu dữ liệu (data types)

Move có nhiều kiểu dữ liệu primitive. Bao gồm Booleans, Unsigned integers và address. 


# Unsigned integer types
Move hỗ trợ sáu kiểu số nguyên không dấu (u8, u16, u32, u64, u128, u256). Các kiểu này có giá trị từ 0 đến giá trị tối đa tương ứng, phụ thuộc vào kích thước của kiểu. Khác với Rust, Move không có số âm hoặc số thập phân.


![](../assets/Basic_Move_Programming_image/unsigned_integer.png)


Các số có thể được biểu diễn dưới dạng thập phân hoặc thập lục phân(Hex):
```
// Decimal representation
let x: u8 = 10;

// Hexadecimal representation
let y: u8 = 0xa;

```


Nếu như kiểu dữ liệu không được xác định rõ. Thì compiler sẽ tự động xác định dựa trên ngữ cảnh. Nếu như kiểu vẫn không thể xác định được thì mặc định là `u64`. Nếu một giá trị số quá lớn so với phạm vi kích thước đã được chỉ định sẽ thông báo lỗi. 

## Các phép tính trong Move

Đối với các phép toán số học (cộng, trừ, nhân, chia, chia lấy dư) trên các kiểu dữ liệu này này, hai toán hạng phải cùng kiểu. Nếu bạn cần thực hiện phép toán trên các giá trị có kiểu khác nhau, bạn phải thực hiện **ép kiểu tường minh** (exclicit casting) trước. Lưu ý tất cả các phép toán số học sẽ dừng khi xảy ra tràn số hoặc chia cho không điều này để ngăn chặn các kiểu tấn công tràn số và tăng cường bảo mật cho chương trình.

![](../assets/Basic_Move_Programming_image/arithmetic_operation.png)


## Cách để ép kiểu trong Move( casting)

Trong Move, sử dụng `as` cho việc ép kiểu dữ liệu, cho phép một số nguyên có kích thước này được chuyển đổi thành số nguyên có kích thước khác. Nếu kết quả quá lớn so với kiểu được chỉ định, việc ép kiểu sẽ bị dừng lại (ví dụ: ép kiểu một giá trị u16 thành u8 có thể gây tràn số).


![](../assets/Basic_Move_Programming_image/casting_types.png)

Kiểu dữ liệu Integers là kiểu duy nhất trong Move hỗ trợ cho việc ép kiểu(casting). Ví dụ dưới đây ta có thể đổi y sang u64 cho phép tính toán với giá trị z: 

```rust 

public fun casting_function() {
    let x: u8 = 94; 

    // 
    let y: u64 = x as u64;

    let _z = 98u64 + y; 

}

```

Đây là một số ví dụ khác về việc casting: 

```rust
(x as u8)
(y as u16)
(87316 as u32)
(2u8 as u64)
(1 + 3 as u128)
(4/2 + 12345 as u256)
```



# Boolean 

Trong Sui move, Boolean hoạt động giống với các ngôn ngữ khác đều có 2 giá trị là true và false. Kiểu boolean thường được dùng cho các phần điều kiện ( control program flow). Ví dụ cho kiểu dữ liệu boolean: 

```rust 
let x: bool = true; 
let mut y: bool = false; 
```

Kiểu Boolean hỗ trợ cho các toán tử logic: 

* Toán tử && (`AND`),`p && q` sẽ tương đương với `if(p) q else false`, nghĩa là nó chỉ true khi cả 2 đều true
* Toán tử || (`OR`), `p || q` sẽ tương đương với `if(p) true else q`, nghĩa là một trong hai đó là true thì sẽ true.
* Toán tử ! (`NOT`), `!p` sẽ tương đương với `if (p) false else true`, nghĩa là phủ định



import React, { useState } from 'react';

export const LogicalOperatorQuiz = () => {
  const [selected, setSelected] = useState(null);
  const [isCorrect, setIsCorrect] = useState(false);

  const handleSelect = (operator) => {
    setSelected(operator);
    setIsCorrect(operator === '&&');
  };

  return (
    <div className="p-4 bg-white dark:bg-gray-800 shadow-md rounded-md">
      <p className="text-lg font-semibold mb-4 text-black dark:text-white">
        Trong logic lập trình, nếu tất cả các điều kiện đều phải được thỏa mãn thì nên sử dụng toán tử logic nào?
      </p>
      <div className="flex space-x-4">
        <button
          onClick={() => handleSelect('&&')}
          className={`px-4 bg-white py-2 rounded-md transition-colors duration-200 text-white ${
            selected === '&&' ? 'bg-gray-300 dark:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600'
          }`}
        >
          &&
        </button>
        <button
          onClick={() => handleSelect('||')}
          className={`px-4 py-2 rounded-md transition-colors duration-200 text-white ${
            selected === '||' ? 'bg-gray-300 dark:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600'
          }`}
        >
          ||
        </button>
        <button
          onClick={() => handleSelect('!!')}
          className={`px-4 py-2 rounded-md transition-colors duration-200 text-white ${
            selected === '!!' ? 'bg-gray-300 dark:bg-gray-600' : 'bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600'
          }`}
        >
          !!
        </button>
      </div>
      {selected && (
        <p className={`mt-4 text-sm ${isCorrect ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
          {isCorrect ? 'Correct!' : 'Try again!'}
        </p>
      )}
    </div>
  );
};

Để hiểu thêm thì bạn có thể trả lời bài quiz sau: 

<LogicalOperatorQuiz />


## What is variable shadowing?
Trước khi giải thích về shadowing. Mình có một ví dụ sau đây trong function immute_fun có một giá trị không thể thay đổi là _x:

```rust
public fun immute_fun() {
    let _x: bool = true;
    _x = false;
}

```

Khi chạy lệnh `sui move build` bạn sẽ gặp lỗi sau: 

![](../assets/Basic_Move_Programming_image/shadowning_example.png)

Lỗi này cho thấy bạn không thể thay đổi giá trị của _x được vì đó là giá trị immutable. Như vậy bạn cần khai báo lại giá trị thành mutable mut_X 


```rust 
public fun mute_fun(){
    let mut _x: bool = true;
    _x = false;
}

```


Variable shadowing xảy ra khi mà một biến mới trùng têm được khai báo cùng tên. Tại thời điểm này, có hai biến tồn tại trong chương trình. Do đều nằm trong một phạm vi (scope) 

